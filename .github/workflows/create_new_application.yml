name: "[Call] Create New Application"

on:
  workflow_call:
    inputs:
      application_name:
        description: "the name of the application (new repo name)"
        required: true
        type: string
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true

jobs:
  bootstrap:
    runs-on: arc-runner-set

    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.application_name }}
      TEMPLATE_OWNER: webgrip
      TEMPLATE_REPO: application-template
      REPLACE_TOKEN: "application-application"
      VISIBILITY: "public"
      AI_CHANGE: "no"
      APP_BOT_SLUG: ${{ vars.WEBGRIP_CI_BOT_NAME || 'webgrip-ci' }}
      BOOTSTRAP_BRANCH: bootstrap/init-${{ github.run_id }}

    steps:
      - name: Silence local git init default-branch hint
        run: git config --global init.defaultBranch main

      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}

      - name: Create repo from template (no history)
        id: gen
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = process.env.ORG;
            const name = process.env.NEW_REPO;
            const isPrivate = (process.env.VISIBILITY !== 'public');
            const r = await github.request('POST /repos/{template_owner}/{template_repo}/generate', {
              template_owner: process.env.TEMPLATE_OWNER,
              template_repo: process.env.TEMPLATE_REPO,
              owner: org,
              name,
              private: isPrivate,
              include_all_branches: false
            });
            core.info(`Generated repo: ${r.data.full_name}`);

      - name: Wait for initial default branch
        id: wait-default-branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const start = Date.now();
            const timeoutMs = 180_000;
            let sleepMs = 2_000;
            const maxSleepMs = 10_000;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            async function ready() {
              const { data: repoData } = await github.request('GET /repos/{owner}/{repo}', { owner, repo });
              const branch = repoData.default_branch || 'main';
              try {
                const { data: b } = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
                if (b?.commit?.sha) return { branch, sha: b.commit.sha };
              } catch {}
              try {
                const { data: c } = await github.request('GET /repos/{owner}/{repo}/commits/{ref}', { owner, repo, ref: branch });
                if (c?.sha) return { branch, sha: c.sha };
              } catch {}
              return null;
            }
            while (Date.now() - start < timeoutMs) {
              const info = await ready();
              if (info) {
                core.setOutput('initial_branch', info.branch);
                core.setOutput('initial_sha', info.sha);
                core.exportVariable('INITIAL_BRANCH', info.branch);
                core.exportVariable('INITIAL_SHA', info.sha);
                return;
              }
              await sleep(sleepMs);
              sleepMs = Math.min(maxSleepMs, Math.floor(sleepMs * 1.6));
            }
            core.setFailed('Timed out waiting for the new repo default branch and first commit.');

      - name: Create development branch from initial commit
        id: create-dev
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const fromSha = process.env.INITIAL_SHA || "${{ steps.wait-default-branch.outputs.initial_sha }}";
            try {
              await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch: 'development' });
            } catch {
              await github.request('POST /repos/{owner}/{repo}/git/refs', {
                owner, repo,
                ref: 'refs/heads/development',
                sha: fromSha
              });
            }

      - name: Set default branch to development
        id: set-default
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            await github.request('PATCH /repos/{owner}/{repo}', {
              owner: process.env.ORG,
              repo: process.env.NEW_REPO,
              default_branch: 'development'
            });

      - name: Check out new repo (development)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORG }}/${{ env.NEW_REPO }}
          ref: development
          fetch-depth: 0
          persist-credentials: false
          token: ${{ steps.app-token.outputs.token }}

      - name: remove unwanted files
        shell: bash
        run: |
          set -euo pipefail
          rm -rf CHANGELOG.md

      - name: Derive name variants
        id: namevars
        shell: bash
        run: |
          set -euo pipefail
          kebab="${NEW_REPO}"
          snake="${kebab//-/_}"
          upper_snake="${snake^^}"
          IFS=- read -ra parts <<< "$kebab"
          pascal=""
          camel=""
          title=""
          for i in "${!parts[@]}"; do
            p="${parts[$i]}"
            cap="${p^}"
            pascal+="$cap"
            title+="$cap "
            if [[ $i -eq 0 ]]; then camel+="${p,,}"; else camel+="$cap"; fi
          done
          title="${title% }"
          {
            echo "kebab=$kebab"
            echo "snake=$snake"
            echo "upper_snake=$upper_snake"
            echo "pascal=$pascal"
            echo "camel=$camel"
            echo "title=$title"
          } >> "$GITHUB_OUTPUT"

      - name: Replace token (kebab)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: ${{ env.REPLACE_TOKEN }}
          replace: ${{ steps.namevars.outputs.kebab }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Replace token (snake)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "application_application"
          replace: ${{ steps.namevars.outputs.snake }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Replace token (UPPER_SNAKE)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "APPLICATION_APPLICATION"
          replace: ${{ steps.namevars.outputs.upper_snake }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Replace token (PascalCase)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "ApplicationApplication"
          replace: ${{ steps.namevars.outputs.pascal }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Replace token (camelCase)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "applicationApplication"
          replace: ${{ steps.namevars.outputs.camel }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Replace token (Title Case with space)
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "Application Application"
          replace: ${{ steps.namevars.outputs.title }}
          include: "**/*"
          exclude: ".git/**"
          regex: false

      - name: Rename files & directories
        shell: bash
        run: |
          set -euo pipefail
          token="${REPLACE_TOKEN}"
          repl="${NEW_REPO}"
          while IFS= read -r -d '' p; do
            base="$(basename "$p")"
            newbase="${base//$token/$repl}"
            if [[ "$base" != "$newbase" ]]; then
              dir="$(dirname "$p")"
              git mv "$p" "${dir}/${newbase}"
            fi
          done < <(find . -depth -name "*${token}*" -print0)

      - name: Resolve bot noreply email
        id: bot-email
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const slug = process.env.APP_BOT_SLUG;
            const username = `${slug}[bot]`;
            try {
              const { data: user } = await github.request('GET /users/{username}', { username });
              core.setOutput('name', username);
              core.setOutput('email', `${user.id}+${username}@users.noreply.github.com`);
            } catch {
              core.setOutput('name', 'github-actions[bot]');
              core.setOutput('email', '41898282+github-actions[bot]@users.noreply.github.com');
            }

      - name: Authenticate git remote for push
        env:
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git remote set-url origin "https://x-access-token:${APP_TOKEN}@github.com/${ORG}/${NEW_REPO}.git"

      - name: Create bootstrap branch, commit, and push
        run: |
          set -euo pipefail
          git checkout -b "${BOOTSTRAP_BRANCH}"
          git config user.name  "${{ steps.bot-email.outputs.name }}"
          git config user.email "${{ steps.bot-email.outputs.email }}"
          git add -A
          if git diff --cached --quiet; then
            echo "Nothing to commit"
          else
            git commit -m "chore(init): personalize ${NEW_REPO}"
          fi
          git push -u origin "${BOOTSTRAP_BRANCH}"

      - name: Open PR into development and merge (GraphQL)
        id: pr-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const name  = process.env.NEW_REPO;
            const head  = process.env.BOOTSTRAP_BRANCH;
            const base  = 'development';

            // Get repository node id
            const repoQ = await github.graphql(
              `query($owner:String!, $name:String!){
                 repository(owner:$owner, name:$name){ id }
               }`,
              { owner, name }
            );
            const repositoryId = repoQ.repository.id;

            // Find existing open PR from head->base
            const openPRs = await github.graphql(
              `query($owner:String!, $name:String!, $head:String!, $base:String!){
                 repository(owner:$owner, name:$name){
                   pullRequests(first: 1, states: OPEN, headRefName: $head, baseRefName: $base){
                     nodes { id number headRefOid }
                   }
                 }
               }`,
              { owner, name, head, base }
            );

            let pr = openPRs.repository.pullRequests.nodes[0];

            // Create PR if not found
            if (!pr) {
              const create = await github.graphql(
                `mutation($input: CreatePullRequestInput!){
                   createPullRequest(input: $input){
                     pullRequest { id number headRefOid }
                   }
                 }`,
                { input: {
                    repositoryId,
                    headRefName: head,
                    baseRefName: base,
                    title: `chore(init): personalize ${name}`
                  }
                }
              );
              pr = create.createPullRequest.pullRequest;
            }

            // Try to merge PR
            try {
              await github.graphql(
                `mutation($input: MergePullRequestInput!){
                   mergePullRequest(input: $input){
                     pullRequest { merged }
                   }
                 }`,
                { input: {
                    pullRequestId: pr.id,
                    expectedHeadOid: pr.headRefOid,
                    mergeMethod: "SQUASH"
                  }
                }
              );
            } catch (e) {
              core.setFailed(`Failed to merge PR #${pr.number}: ${e.message}`);
            }

            // Delete the bootstrap branch ref (best-effort) via GraphQL
            try {
              const refQ = await github.graphql(
                `query($owner:String!, $name:String!, $qref:String!){
                   repository(owner:$owner, name:$name){
                     ref(qualifiedName: $qref){ id }
                   }
                 }`,
                { owner, name, qref: `refs/heads/${head}` }
              );
              if (refQ.repository.ref?.id) {
                await github.graphql(
                  `mutation($input: DeleteRefInput!){
                     deleteRef(input: $input){ clientMutationId }
                   }`,
                  { input: { refId: refQ.repository.ref.id } }
                );
              }
            } catch {}

      - name: Protect branches (main & development)
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const protection = {
              required_status_checks: { strict: true, contexts: [] },
              enforce_admins: true,
              required_pull_request_reviews: {
                required_approving_review_count: 1,
                require_code_owner_reviews: true,
                dismiss_stale_reviews: true
              },
              restrictions: null,
              allow_force_pushes: false,
              allow_deletions: false,
              required_linear_history: true
            };
            async function protect(branch) {
              await github.request('PUT /repos/{owner}/{repo}/branches/{branch}/protection', {
                owner, repo, branch, ...protection, mediaType: { previews: ['luke-cage'] }
              });
            }
            await protect('main');
            await protect('development');
