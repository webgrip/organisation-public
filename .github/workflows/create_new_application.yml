name: "[Call] Create New Application"

on:
  workflow_call:
    inputs:
      application_name:
        description: "the name of the application (new repo name)"
        required: true
        type: string
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true

jobs:
  bootstrap:
    runs-on: arc-runner-set
    name: ${{ inputs.application_name }}

    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.application_name }}
      TEMPLATE_OWNER: webgrip
      TEMPLATE_REPO: application-template
      REPLACE_TOKEN: "application-application"
      VISIBILITY: "public"
      AI_CHANGE: "no"
      APP_BOT_SLUG: ${{ vars.WEBGRIP_CI_BOT_NAME || 'webgrip-ci' }}

    steps:
      - name: Silence local git init default-branch hint
        run: git config --global init.defaultBranch main

      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}

      - name: Create repo from template (no history) + set topics + merge options
        id: gen
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = process.env.ORG;
            const name = process.env.NEW_REPO;
            const isPrivate = (process.env.VISIBILITY !== 'public');

            const { data: repo } = await github.request('POST /repos/{template_owner}/{template_repo}/generate', {
              template_owner: process.env.TEMPLATE_OWNER,
              template_repo: process.env.TEMPLATE_REPO,
              owner: org,
              name,
              private: isPrivate,
              include_all_branches: false
            });
            core.info(`Generated repo: ${repo.full_name}`);

            const topics = ["application"];
            await github.request('PUT /repos/{owner}/{repo}/topics', {
              owner: org,
              repo: name,
              names: topics
            });
            core.info(`Added topics: ${topics.join(", ")}`);

            await github.request('PATCH /repos/{owner}/{repo}', {
              owner: process.env.ORG,
              repo: process.env.NEW_REPO,
              allow_squash_merge: false,
              allow_merge_commit: false,
              allow_rebase_merge: true,
              delete_branch_on_merge: true
            });
            core.info(`Configured merge options for ${org}/${name}.`);

      - name: Wait for initial default branch
        id: wait-default-branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const start = Date.now();
            const timeoutMs = 180_000;
            let sleepMs = 2_000;
            const maxSleepMs = 10_000;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            async function ready() {
              const { data: repoData } = await github.request('GET /repos/{owner}/{repo}', { owner, repo });
              const branch = repoData.default_branch || 'main';
              try {
                const { data: b } = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
                if (b?.commit?.sha) return { branch, sha: b.commit.sha };
              } catch {}
              try {
                const { data: c } = await github.request('GET /repos/{owner}/{repo}/commits/{ref}', { owner, repo, ref: branch });
                if (c?.sha) return { branch, sha: c.sha };
              } catch {}
              return null;
            }
            while (Date.now() - start < timeoutMs) {
              const info = await ready();
              if (info) {
                core.setOutput('initial_branch', info.branch);
                core.setOutput('initial_sha', info.sha);
                core.exportVariable('INITIAL_BRANCH', info.branch);
                core.exportVariable('INITIAL_SHA', info.sha);
                return;
              }
              await sleep(sleepMs);
              sleepMs = Math.min(maxSleepMs, Math.floor(sleepMs * 1.6));
            }
            core.setFailed('Timed out waiting for the new repo default branch and first commit.');

      - name: Create development branch from initial commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const fromSha = process.env.INITIAL_SHA || "${{ steps.wait-default-branch.outputs.initial_sha }}";
            try {
              await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch: 'development' });
            } catch {
              await github.request('POST /repos/{owner}/{repo}/git/refs', {
                owner, repo,
                ref: 'refs/heads/development',
                sha: fromSha
              });
            }

      - name: Set default branch to development
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            await github.request('PATCH /repos/{owner}/{repo}', {
              owner: process.env.ORG,
              repo: process.env.NEW_REPO,
              default_branch: 'development'
            });
            core.info('Default branch set to development.');

      - name: Check out new repo (development)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORG }}/${{ env.NEW_REPO }}
          ref: development
          fetch-depth: 0
          persist-credentials: false
          token: ${{ steps.app-token.outputs.token }}

      - name: "Personalize repo (delete files, replace contents, rename/merge paths)"
        uses: actions/github-script@v7
        env:
          TOKEN: ${{ env.REPLACE_TOKEN }}
          REPL: ${{ env.NEW_REPO }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const root = process.env.GITHUB_WORKSPACE || process.cwd();
            const token = process.env.TOKEN;
            const repl  = process.env.REPL;
            function isDir(p) { try { return fs.statSync(p).isDirectory(); } catch { return false; } }
            function isFile(p) { try { return fs.statSync(p).isFile(); } catch { return false; } }
            function walk(dir) {
              const out = [];
              for (const entry of fs.readdirSync(dir)) {
                if (entry === '.git') continue;
                const full = path.join(dir, entry);
                out.push(full);
                if (isDir(full)) out.push(...walk(full));
              }
              return out;
            }
            const changelog = path.join(root, 'CHANGELOG.md');
            if (fs.existsSync(changelog)) { fs.rmSync(changelog, { force: true }); core.info('Removed root CHANGELOG.md'); }
            const all = walk(root);
            const files = all.filter(isFile);
            let replacedCount = 0;
            for (const file of files) {
              try {
                const buf = fs.readFileSync(file);
                if (buf.includes(0)) continue; // likely binary
                let txt = buf.toString('utf8');
                if (!txt.includes(token)) continue;
                const newTxt = txt.split(token).join(repl);
                if (newTxt !== txt) { fs.writeFileSync(file, newTxt, 'utf8'); replacedCount++; }
              } catch {}
            }
            core.info(`Replaced contents in ${replacedCount} file(s).`);
            const toProcess = all.filter(p => p.includes(token)).sort((a, b) => b.length - a.length);
            function moveOrMerge(oldPath, newPath) {
              const isOldDir = isDir(oldPath);
              if (!fs.existsSync(path.dirname(newPath))) fs.mkdirSync(path.dirname(newPath), { recursive: true });
              if (!fs.existsSync(newPath)) { fs.renameSync(oldPath, newPath); return; }
              if (isOldDir) {
                for (const entry of fs.readdirSync(oldPath)) {
                  const src = path.join(oldPath, entry);
                  const dst = path.join(newPath, entry);
                  moveOrMerge(src, dst);
                }
                try { fs.rmdirSync(oldPath); } catch {}
              } else {
                fs.copyFileSync(oldPath, newPath);
                try { fs.unlinkSync(oldPath); } catch {}
              }
            }
            let renameCount = 0;
            for (const oldPath of toProcess) {
              const newPath = oldPath.split(token).join(repl);
              if (newPath !== oldPath) {
                try { moveOrMerge(oldPath, newPath); renameCount++; }
                catch (e) { core.warning(`Rename failed ${oldPath} -> ${newPath}: ${e.message}`); }
              }
            }
            core.info(`Renamed/Merged ${renameCount} path(s).`);

      - name: Resolve bot noreply email
        id: bot-email
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const slug = process.env.APP_BOT_SLUG;
            const username = `${slug}[bot]`;
            try {
              const { data: user } = await github.request('GET /users/{username}', { username });
              core.setOutput('name', username);
              core.setOutput('email', `${user.id}+${username}@users.noreply.github.com`);
            } catch {
              core.setOutput('name', 'github-actions[bot]');
              core.setOutput('email', '41898282+github-actions[bot]@users.noreply.github.com');
            }

      - name: Authenticate git remote for push
        env:
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git remote set-url origin "https://x-access-token:${APP_TOKEN}@github.com/${ORG}/${NEW_REPO}.git"

      - name: Commit and push to development
        run: |
          git config user.name  "${{ steps.bot-email.outputs.name }}"
          git config user.email "${{ steps.bot-email.outputs.email }}"
          git add -A
          git commit -m "chore(init): personalize ${NEW_REPO}" || echo "Nothing to commit"
          git push origin HEAD:development

      - name: Create or update ruleset (main & development)
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;

            async function upsertRuleset() {
              const payload = {
                name: "Default protections (main & development)",
                target: "branch",
                enforcement: "active",
                conditions: {
                  ref_name: {
                    include: ["refs/heads/main", "refs/heads/development"],
                    exclude: []
                  }
                },
                bypass_actors: [
                  { actor_id: 1, actor_type: "OrganizationAdmin", bypass_mode: "always" }
                ],
                rules: [
                  {
                    type: "pull_request",
                    parameters: {
                      automatic_copilot_code_review_enabled: true,
                      dismiss_stale_reviews_on_push: true,
                      require_code_owner_review: true,
                      require_last_push_approval: false,
                      required_approving_review_count: 1,
                      required_review_thread_resolution: true
                    }
                  },
                  {
                    type: "branch_name_pattern",
                    parameters: {
                      name: "Branch name pattern",
                      negate: false,
                      operator: "regex",
                      pattern: "^(feat|fix|chore|docs|style|refactor|perf|test|build|ci|revert)\/.+"
                    }
                  },
                  { type: "non_fast_forward" },
                  { type: "required_linear_history" },
                  { type: "deletion" }
                ]
              };

              const list = await github.request('GET /repos/{owner}/{repo}/rulesets', { owner, repo });
              const existing = (list.data || []).find(r => r.name === payload.name);

              if (existing) {
                await github.request('PATCH /repos/{owner}/{repo}/rulesets/{ruleset_id}', {
                  owner, repo, ruleset_id: existing.id, ...payload
                });
                core.info(`Updated ruleset '${payload.name}' (id: ${existing.id}).`);
              } else {
                const created = await github.request('POST /repos/{owner}/{repo}/rulesets', {
                  owner, repo, ...payload
                });
                core.info(`Created ruleset '${payload.name}' (id: ${created.data.id}).`);
              }
            }

            await upsertRuleset();

      - name: Open PR development
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org  = process.env.ORG;
            const repo = process.env.NEW_REPO;

            const q = `
              query($org:String!, $repo:String!) {
                repository(owner:$org, name:$repo) { id }
              }
            `;
            const r = await github.graphql(q, { org, repo });
            const repositoryId = r.repository.id;

            const m = `
              mutation($repositoryId:ID!, $title:String!, $body:String, $base:String!, $head:String!, $draft:Boolean) {
                createPullRequest(input:{
                  repositoryId:$repositoryId,
                  title:$title,
                  body:$body,
                  baseRefName:$base,
                  headRefName:$head,
                  draft:$draft,
                  maintainerCanModify:true
                }) {
                  pullRequest { number url }
                }
              }
            `;
            const title = "chore(init): personalize repository";
            const body  = "Automated initialization PR from \`development\` to \`main\`.";
            const pr = await github.graphql(m, {
              repositoryId,
              title,
              body,
              base: "main",
              head: "development",
              draft: false
            });
            core.info(`PR opened: #${pr.createPullRequest.pullRequest.number} ${pr.createPullRequest.pullRequest.url}`);
