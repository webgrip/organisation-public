name: "🔃🏷️ Sync Labels by Topics"

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Plan only (no changes)"
        type: boolean
        default: false
  schedule:
    - cron: "23 4 * * 1" # optional: Mondays 04:23 UTC

permissions:
  contents: read
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      CONFIG_PATH: .github/labels-by-topic.json
      MGMT_MARKER: "(managed by topics)"
    steps:
      - name: Check out (to read config)
        uses: actions/checkout@v4

      - name: Sync labels across org repos with matching topics
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const org = "${{ github.repository_owner }}";
            const isDryRun = core.getBooleanInput('dry_run');

            // ---- Helpers ----
            const MGMT_MARKER = process.env.MGMT_MARKER;
            const withMarker = (desc) => {
              const base = (desc || '').replace(/\s*\(managed by topics\)\s*$/i, '').trim();
              return base ? `${base} ${MGMT_MARKER}` : MGMT_MARKER;
            };
            const hasMarker = (desc) => (desc || '').includes(MGMT_MARKER);
            const normalizeHex = (c) => {
              const x = String(c || '').replace(/^#/, '').trim();
              if (!/^[0-9a-fA-F]{6}$/.test(x)) throw new Error(`Invalid color: "${c}"`);
              return x.toLowerCase();
            };

            // Load config
            const configPath = process.env.CONFIG_PATH;
            if (!fs.existsSync(configPath)) {
              core.setFailed(`Missing ${configPath}`);
              process.exit(1);
            }
            let cfg;
            try { cfg = JSON.parse(fs.readFileSync(configPath, 'utf8')); }
            catch (e) { core.setFailed(`Invalid JSON in ${configPath}: ${e.message}`); process.exit(1); }

            const prune = !!cfg.prune;
            const topicMap = cfg.topics || {};
            const general = Array.isArray(cfg.general) ? cfg.general : [];

            // Topic keys we care about (slugs)
            const topicKeys = Object.keys(topicMap).map(k => k.toLowerCase());

            // ---- Find repos by topic (union) ----
            // We'll search once per topic and union the repos.
            const reposMap = new Map(); // full_name -> repo data
            for (const t of topicKeys) {
              // q example: org:my-org topic:application
              const q = `org:${org} topic:${t}`;
              const results = await github.paginate(github.rest.search.repos, {
                q, per_page: 100
              });
              for (const r of results) {
                if (r.archived || r.disabled) continue; // skip archived/disabled
                reposMap.set(r.full_name, { owner: r.owner.login, repo: r.name });
              }
            }

            if (reposMap.size === 0) {
              core.info(`No repositories in ${org} matched any configured topics.`);
              await core.summary
                .addHeading('Org Labels by Topics — Sync')
                .addRaw(`No target repositories found for topics: ${topicKeys.join(', ') || '(none)'} in ${org}.`)
                .write();
              return;
            }

            const perRepoSummaries = [];

            // ---- Process each repo ----
            // Batch processing to avoid rate limits
            const reposArray = Array.from(reposMap.entries());
            const BATCH_SIZE = 5; // adjust as needed
            const BATCH_DELAY_MS = 5000; // 5 seconds between batches

            async function processRepo(fullName, { owner, repo }) {
              core.startGroup(`Repo: ${owner}/${repo}`);

              // Get all topics for this repo (so we can take the union for all matching keys)
              const topicsResp = await github.request('GET /repos/{owner}/{repo}/topics', {
                owner, repo,
                headers: { accept: 'application/vnd.github+json' }
              });
              const repoTopics = (topicsResp.data.names || []).map(t => t.toLowerCase());

              // Desired labels = general + union of labels for any matching topic keys present
              const desired = new Map();

              // general first
              for (const lbl of general) {
                if (!lbl || !lbl.name) continue;
                desired.set(lbl.name.toLowerCase(), {
                  name: String(lbl.name),
                  color: normHex(lbl.color || 'cccccc'),
                  description: withMarker(lbl.description || '')
                });
              }

              // topic labels override general on name collision
              for (const present of repoTopics) {
                const key = topicKeys.find(k => k === present);
                if (!key) continue;
                for (const lbl of (topicMap[key] || [])) {
                  if (!lbl || !lbl.name) continue;
                  desired.set(lbl.name.toLowerCase(), {
                    name: String(lbl.name),
                    color: normHex(lbl.color || 'cccccc'),
                    description: withMarker(lbl.description || '')
                  });
                }
              }

              // If no desired labels (e.g., repo only had unrelated topics), skip
              if (desired.size === 0) {
                core.info('No configured topics present; skipping.');
                core.endGroup();
                return null;
              }

              // Existing labels
              const existing = await github.paginate(github.rest.issues.listLabelsForRepo, {
                owner, repo, per_page: 100
              });
              const existingByLower = new Map(existing.map(l => [l.name.toLowerCase(), l]));

              const ensured = [];
              const updated = [];
              const removed = [];

              // Create/update
              for (const [k, d] of desired) {
                const found = existingByLower.get(k);
                if (!found) {
                  core.info(`Create: ${d.name}`);
                  if (!dryRun) {
                    await github.rest.issues.createLabel({
                      owner, repo,
                      name: d.name, color: d.color, description: d.description
                    }).catch(async (err) => {
                      if (err.status === 422 && /already exists/i.test(err.message)) {
                        const match = existing.find(l => l.name.toLowerCase() === k);
                        if (match) {
                          await github.rest.issues.updateLabel({
                            owner, repo,
                            name: match.name, new_name: d.name, color: d.color, description: d.description
                          });
                        } else { throw err; }
                      } else { throw err; }
                    });
                  }
                  ensured.push(d.name);
                } else {
                  const needsRename = found.name !== d.name;
                  const needsColor  = (found.color || '').toLowerCase() !== d.color;
                  const needsDesc   = (found.description || '') !== d.description;
                  if (needsRename || needsColor || needsDesc) {
                    core.info(`Update: ${found.name} -> ${d.name}`);
                    if (!dryRun) {
                      await github.rest.issues.updateLabel({
                        owner, repo,
                        name: found.name, new_name: d.name, color: d.color, description: d.description
                      });
                    }
                    updated.push(d.name);
                  } else {
                    core.info(`OK: ${found.name}`);
                  }
                }
              }

              // Prune previously managed labels that are not desired
              if (prune) {
                const desiredSetLower = new Set([...desired.values()].map(v => v.name.toLowerCase()));
                for (const l of existing) {
                  const isManaged = hasMarker(l.description || '');
                  const isDesired = desiredSetLower.has(l.name.toLowerCase());
                  if (isManaged && !isDesired) {
                    core.info(`Delete: ${l.name}`);
                    if (!dryRun) {
                      await github.rest.issues.deleteLabel({ owner, repo, name: l.name });
                    }
                    removed.push(l.name);
                  }
                }
              }

              core.endGroup();

              return {
                repo: `${owner}/${repo}`,
                topics: repoTopics,
                ensured,
                updated,
                removed
              };
            }

            async function sleep(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            for (let i = 0; i < reposArray.length; i += BATCH_SIZE) {
              const batch = reposArray.slice(i, i + BATCH_SIZE);
              const results = await Promise.all(batch.map(([fullName, repoObj]) =>
                processRepo(fullName, repoObj).catch(err => {
                  core.error(`Error processing ${repoObj.owner}/${repoObj.repo}: ${err.message}`);
                  return null;
                })
              ));
              for (const summary of results) {
                if (summary) perRepoSummaries.push(summary);
              }

              // Check rate limit and delay if needed
              const rate = await github.rest.rateLimit.get();
              const remaining = rate.data.resources.core.remaining;
              const reset = rate.data.resources.core.reset;
              core.info(`GitHub API remaining: ${remaining}`);
              if (remaining < 20) {
                const now = Math.floor(Date.now() / 1000);
                const waitSec = Math.max(reset - now, 1);
                core.warning(`Approaching rate limit, sleeping for ${waitSec} seconds`);
                await sleep(waitSec * 1000);
              } else if (i + BATCH_SIZE < reposArray.length) {
                core.info(`Sleeping ${BATCH_DELAY_MS / 1000}s before next batch...`);
                await sleep(BATCH_DELAY_MS);
              }
            }

            // ---- Summary ----
            const table = [
              [{data:'Repo'},{data:'Topics'},{data:'Ensured'},{data:'Updated'},{data:'Removed'}]
            ];
            for (const row of perRepoSummaries) {
              table.push([
                { data: row.repo },
                { data: row.topics.join(', ') || '(none)' },
                { data: row.ensured.length ? row.ensured.join(', ') : '—' },
                { data: row.updated.length ? row.updated.join(', ') : '—' },
                { data: row.removed.length ? row.removed.join(', ') : '—' }
              ]);
            }

            await core.summary
              .addHeading(`Org Labels by Topics — ${isDryRun ? 'PLAN' : 'APPLY'}`)
              .addTable(table)
              .write();
